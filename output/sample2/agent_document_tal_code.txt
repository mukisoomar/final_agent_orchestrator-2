! ===========================================================================
! Comprehensive TAL Program Sample
! Demonstrates arrays, pointers, subprocs, global variables, external callouts,
! assignments, byte array operations, bit manipulation, and other TAL features
! ===========================================================================

! Declare the program name
NAME inventory_system;

! Forward declarations for procedures and structures defined later in the code
FORWARD PROC print_error;
FORWARD STRUCT customer_record;

! Declare external procedures (defined in separate compilation units)
EXTERNAL PROC log_transaction;
EXTERNAL PROC fetch_customer_data;

! Define global literal constants
LITERAL max_items = 1000;       ! Maximum number of inventory items
LITERAL max_customers = 500;    ! Maximum number of customers
LITERAL buffer_size = 4096;     ! Size of the general-purpose buffer
LITERAL success = 0;            ! Status code for successful operation
LITERAL error_file_not_found = 1; ! Error code for file not found
LITERAL error_invalid_input = 2;  ! Error code for invalid user input
LITERAL error_system = 3;       ! Generic system error code

! Define basic data types (aliases for standard types)
INT item_id;
STRING item_name;

! Define the structure for an inventory item record
STRUCT item_record;
BEGIN
  INT item_id;                  ! Unique identifier for the item
  STRING item_name[0:30];       ! Name of the item (31 characters)
  FIXED(2) item_price;          ! Price of the item with 2 decimal places
  INT quantity_on_hand;         ! Current stock quantity
  INT reorder_level;            ! Minimum quantity before reordering
  INT supplier_id;              ! ID of the item's supplier
  STRING last_updated[0:10];    ! Date of last update (11 characters, e.g., YYYY-MM-DD)
END;

! Define the structure for a customer record
STRUCT customer_record;
BEGIN
  INT customer_id;              ! Unique identifier for the customer
  STRING customer_name[0:50];   ! Customer's name (51 characters)
  STRING address_line1[0:30];   ! Address line 1 (31 characters)
  STRING address_line2[0:30];   ! Address line 2 (31 characters)
  STRING city[0:20];            ! City (21 characters)
  STRING state[0:2];            ! State abbreviation (3 characters)
  STRING zip_code[0:9];         ! ZIP code (10 characters)
  FIXED(2) account_balance;     ! Customer's account balance
  FILLER 2;                     ! Padding to ensure proper alignment of subsequent fields
  ! Bit flags packed into a single word for customer attributes
  UNSIGNED(1) is_active;        ! 1 bit: 1 if active, 0 if inactive
  UNSIGNED(1) has_credit;       ! 1 bit: 1 if has credit line, 0 otherwise
  UNSIGNED(1) tax_exempt;       ! 1 bit: 1 if tax exempt, 0 otherwise
  UNSIGNED(13) reserved;        ! 13 bits: Reserved for future use
END;

! Declare a pointer to a system global variable (e.g., system time)
INT .SG system_time;

! Declare global variables
INT error_code := 0;            ! Stores the last error code encountered, initialized to 0
! Define an array of error messages, initialized ('P' indicates persistent/initialized data)
STRING error_messages[0:3] = 'P' := ["Success", "File not found", "Invalid input", "System error"];
INT transaction_count := 0;     ! Counter for the number of transactions processed
! Declare the main inventory array using the item_record structure
STRUCT item_record inventory[0:max_items-1];
INT inventory_count := 0;       ! Current number of items in the inventory array

! Declare global pointers
INT .EXT error_ptr;             ! External pointer to an integer (potentially error_code)
STRUCT customer_record .current_customer; ! Pointer to a customer_record structure
STRING .buffer;                 ! Pointer to a string buffer

! Declare read-only (persistent) arrays initialized at compile time
INT command_codes[0:5] = 'P' := [1, 2, 3, 4, 5, 6]; ! Numeric codes for commands
STRING command_names[0:5] = 'P' := ["ADD", "DELETE", "UPDATE", "QUERY", "REPORT", "EXIT"]; ! String names for commands

! Declare equivalenced variables (aliases for other variables or memory locations)
INT last_error = error_code;    ! last_error is another name for error_code
INT buffer_length = 'G'[10];    ! buffer_length refers to a specific global system location (example)

! Declare a global block structure for I/O related variables
BLOCK inventory_io;
  STRING filename[0:30];        ! Name of the inventory file
  INT file_error;               ! Status code from file operations
  INT record_count;             ! Number of records processed during I/O
END BLOCK;

! ===========================================================================
! Main procedure - Program entry point
! ===========================================================================
INT PROC main_proc, MAIN;
  ! Declare local variables for the main procedure
  INT i;                        ! Loop counter
  INT status;                   ! Status variable for function calls
  STRING input_buffer[0:100];   ! Buffer for user input
  STRING temp_str[0:50];        ! Temporary string variable
  INT j;                        ! Another loop counter or general integer variable
  INT cmd;                      ! Stores the user command code
BEGIN
  ! Allocate and initialize the global buffer pointer with spaces
  buffer := buffer_size * [" "];

  ! Call subprocedure to populate the inventory with initial data
  CALL initialize_inventory;

  ! Main command processing loop
  cmd := 0;                     ! Initialize command variable
  ! Loop until the user chooses the EXIT command (code 6)
  WHILE cmd <> 6 DO
    ! Display the menu options to the user
    CALL display_menu;
    ! Read the command code entered by the user
    CALL read_command(cmd);

    ! Process the entered command using a CASE statement
    CASE cmd OF
    BEGIN
      1: CALL add_item;         ! Call procedure to add an item
      2: CALL delete_item;       ! Call procedure to delete an item
      3: CALL update_item;       ! Call procedure to update an item
      4: CALL query_item;        ! Call procedure to query an item
      5: CALL generate_report;   ! Call procedure to generate a report
      6: ;                       ! Do nothing, loop will terminate
      ! Handle invalid command codes
      OTHERWISE
        error_code := error_invalid_input; ! Set the error code
        CALL print_error;           ! Display the error message
    END;

    ! Log the transaction if it wasn't the EXIT command
    IF cmd <> 6 THEN
      transaction_count := transaction_count + 1; ! Increment transaction counter
      ! Call external procedure to log the transaction details
      CALL log_transaction(cmd, transaction_count);
    ENDIF;
  ENDWHILE;

  ! Program cleanup section
  ! Assign the address of error_code to the error_ptr pointer
  error_ptr := @error_code;
  ! Check if the pointer is not null (redundant here, but demonstrates pointer usage)
  IF error_ptr <> 0 THEN
    ! If there was an error code set during execution, print it before exiting
    IF error_code <> success THEN
        CALL print_error;
    ENDIF;
  ENDIF;

  ! Example of structure pointer usage and bit manipulation
  ! Check if there are items in the inventory
  IF inventory_count > 0 THEN
    ! Allocate memory for a customer record and point current_customer to it (conceptual - TAL might require explicit allocation)
    ! This example assumes current_customer points to valid memory or a global instance
    ! current_customer := @customer_record; ! This line might need adjustment based on actual TAL memory management
    ! Set bit flags: Mark the customer as active and tax exempt
    current_customer.is_active := 1;
    current_customer.tax_exempt := 1;
    ! Clear the reserved bits
    current_customer.reserved := 0;
  ENDIF;

  ! Return success status code to the operating system
  RETURN success;
END;

! ===========================================================================
! Subprocedures - Modular functions called by the main procedure
! ===========================================================================

! Subprocedure to initialize the inventory array with sample data
PROC initialize_inventory;
  INT i; ! Local loop counter (though not used in this version)
BEGIN
  ! Set the count of active inventory items
  inventory_count := 3;

  ! Populate the first inventory record (index 0)
  inventory[0].item_id := 1001;
  inventory[0].item_name := "Widget A";
  inventory[0].item_price := 19.99F; ! F suffix denotes FIXED type
  inventory[0].quantity_on_hand := 150;
  inventory[0].reorder_level := 25;
  inventory[0].supplier_id := 101;
  inventory[0].last_updated := "2025-04-01";

  ! Populate the second inventory record (index 1)
  inventory[1].item_id := 1002;
  inventory[1].item_name := "Widget B";
  inventory[1].item_price := 29.99F;
  inventory[1].quantity_on_hand := 75;
  inventory[1].reorder_level := 15;
  inventory[1].supplier_id := 102;
  inventory[1].last_updated := "2025-04-01";

  ! Populate the third inventory record (index 2)
  inventory[2].item_id := 1003;
  inventory[2].item_name := "Widget C";
  inventory[2].item_price := 39.99F;
  inventory[2].quantity_on_hand := 50;
  inventory[2].reorder_level := 10;
  inventory[2].supplier_id := 101;
  inventory[2].last_updated := "2025-04-01";
END;

! Subprocedure to display the command menu to the user
PROC display_menu;
  INT i; ! Loop counter
BEGIN
  ! Display the menu title
  buffer := "==== Inventory System Menu ====";
  CALL write_line(buffer, 30); ! Assuming write_line writes N chars from buffer

  ! Loop through the command codes and names to display options
  FOR i := 0 TO 5 DO
    ! Format the menu line: "  <code>. <name>"
    buffer := "  ";             ! Start with indentation
    buffer[2] := command_codes[i]; ! Insert command code (implicit conversion)
    buffer[3] := ". ";          ! Add separator
    buffer[5] := command_names[i]; ! Append command name
    ! Display the formatted menu line
    CALL write_line(buffer, 15); ! Assuming write_line writes N chars
  ENDFOR;

  ! Display the prompt for user input
  buffer := "Enter command: ";
  CALL write(buffer, 15); ! Assuming write displays without newline
END;

! Subprocedure to read the user's command (stub)
! Takes an integer parameter by reference to store the command code
PROC read_command(INT REF cmd_code);
BEGIN
  ! Placeholder: In a real program, this would read input from the terminal
  ! and validate it, converting the input string to an integer command code.
  ! For this example, we might simulate reading '1'
  ! cmd_code := 1; ! Example simulation
  ! A more realistic stub might just prompt
  CALL write_line(" (Input simulation - Enter 1-6)", 30);
  ! Assume input is read into a variable, parsed, and stored in cmd_code
  ! For now, let's default to exit to prevent infinite loop in testing
  cmd_code := 6;
END;

! Subprocedure to add a new item to the inventory (stub)
PROC add_item;
BEGIN
  ! Placeholder: Implementation would involve prompting the user for item details,
  ! validating input, finding an empty slot in the inventory array,
  ! and adding the new item_record. Increment inventory_count.
  CALL write_line("Add item procedure called (stub).", 33);
END;

! Subprocedure to delete an item from the inventory (stub)
PROC delete_item;
BEGIN
  ! Placeholder: Implementation would involve prompting for the item ID to delete,
  ! finding the item in the array, removing or marking it as deleted,
  ! and potentially shifting subsequent elements or decrementing inventory_count.
  CALL write_line("Delete item procedure called (stub).", 35);
END;

! Subprocedure to update an existing item's details (stub)
PROC update_item;
BEGIN
  ! Placeholder: Implementation would involve prompting for the item ID to update,
  ! finding the item, prompting for the fields to change, validating input,
  ! and updating the item_record in the array.
  CALL write_line("Update item procedure called (stub).", 35);
END;

! Subprocedure to query and display details of an item (stub)
PROC query_item;
BEGIN
  ! Placeholder: Implementation would involve prompting for the item ID to query,
  ! finding the item in the array, and displaying its details.
  CALL write_line("Query item procedure called (stub).", 34);
END;

! Subprocedure to generate an inventory report (stub)
PROC generate_report;
BEGIN
  ! Placeholder: Implementation would involve iterating through the inventory array
  ! and printing a formatted report of all items or a subset based on criteria.
  CALL write_line("Generate report procedure called (stub).", 38);
END;

! Subprocedure to print an error message based on the global error_code
PROC print_error;
BEGIN
  ! Check if the error code is within the valid range of defined messages
  IF error_code >= 0 AND error_code <= 3 THEN
    ! Display the corresponding error message from the global array
    buffer := "Error: ";
    buffer[7] := error_messages[error_code];
    CALL write_line(buffer, 60); ! Assuming max message length fits
  ELSE
    ! Display a generic error message if the code is unknown
    buffer := "Error: Unknown error code encountered.";
    CALL write_line(buffer, 38);
  ENDIF;
  ! Reset error code after printing (optional, depends on desired behavior)
  ! error_code := success;
END;

! Subprocedure to write a string to the output device (stub)
PROC write_line(STRING line; INT len);
BEGIN
  ! Placeholder: This would typically call a system I/O routine
  ! to print the first 'len' characters of 'line' followed by a newline.
  ! For simulation purposes, could do nothing or log to a console if available.
  ! Outputting the string length for debugging:
  ! DEBUG(line, len);
END;

! Subprocedure to write a string to the output device without newline (stub)
PROC write(STRING line; INT len);
BEGIN
  ! Placeholder: This would typically call a system I/O routine
  ! to print the first 'len' characters of 'line' without a newline.
  ! DEBUG(line, len);
END;